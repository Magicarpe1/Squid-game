<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Squid Game - Gestion des Joueurs</title>
  <style>
    @font-face {
      font-family: "GameOfSquids";
      src: url("https://ik.imagekit.io/lakolo/GameOfSquids-1GMVL.ttf");
    }
    @font-face {
      font-family: "PlayerFont";
      src: url("https://ik.imagekit.io/lakolo/JMH%20Beda.ttf");
    }

    body {
      font-family: "GameOfSquids", sans-serif;
      background-color: #101010;
      color: white;
      text-align: center;
      margin: 0;
      padding: 20px;
    }

    h1 {
      font-size: 3rem;
      margin: 20px 0;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      color: white;
    }
    h1 span {
      display: inline-block;
      font-family: "GameOfSquids", sans-serif;
      font-size: 3rem;
    }
    h1 span.shape-circle {
      color: #ff3e68;
    }
    h1 span.shape-triangle {
      color: #ff3e68;
    }
    h1 span.shape-square {
      color: #ff3e68;
      transform: scale(1.4);
      display: inline-block;
    }

    /* Conteneur global */
    #players-global {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
    }

    /* Conteneur de toutes les teams (ou sans team) */
    .teams-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
    }

    .team-block {
      border: 2px solid #fff;
      border-radius: 5px;
      padding: 10px;
      min-width: 180px;
    }
    .team-block h2 {
      margin: 5px 0 10px;
      font-size: 1.4rem;
      color: #ffdf00;
    }

    .player-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .player-card {
      width: 80px;
      height: 120px;
      border: 2px solid white;
      border-radius: 5px;
      background-color: #007575; /* Couleur identique pour cartes et boules */
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      cursor: pointer;
      font-family: "PlayerFont", sans-serif;
      position: relative;
    }
    .player-card.active {
      border-color: limegreen;
      background-color: #0a0;
    }
    .player-card.no-lives {
      background-color: #505050 !important;
      opacity: 0.7;
    }

    .player-card-number {
      font-size: 2rem;
      color: white;
      background-color: #005050;
      padding: 5px 10px;
      border: 2px solid white;
      border-radius: 5px;
    }
    .player-lives {
      font-size: 1.6rem;
      color: white;
      margin-top: 5px;
    }

    .buttons-container {
      margin-top: 20px;
    }
    button {
      padding: 10px 20px;
      font-size: 1.2rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin: 0 10px;
      font-family: "GameOfSquids", sans-serif;
    }
    #submit-btn {
      background-color: #ff3e68;
      color: white;
    }
    #submit-btn:hover {
      background-color: #c32d4e;
    }
    #reset-btn {
      background-color: #32cd32;
      color: white;
    }
    #reset-btn:hover {
      background-color: #228b22;
    }
    #undo-btn {
      background-color: #888;
      color: white;
    }
    #undo-btn:hover {
      background-color: #555;
    }
    #voice-btn {
      background-color: #3f51b5;
      color: white;
    }
    #voice-btn:hover {
      background-color: #303f9f;
    }
    #teams-btn {
      background-color: #ffd700;
      color: #000;
    }
    #teams-btn:hover {
      background-color: #ffc300;
    }
    #break-teams-btn {
      background-color: #666;
      color: white;
    }
    #break-teams-btn:hover {
      background-color: #444;
    }

    #lives-input {
      padding: 10px;
      font-size: 1.2rem;
      border-radius: 5px;
      border: 1px solid #fff;
      margin: 0 20px;
      background-color: #202020;
      color: #fff;
    }

    .minus-life {
      position: absolute;
      color: red;
      font-size: 1.5rem;
      font-weight: bold;
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: none;
    }

    /* Overlay winners */
    #winners-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 99999;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 20px;
      padding: 20px;
    }
    .winner-clone {
      width: 140px;
      height: 200px;
      margin: 10px;
      background-color: #007575;
      border: 3px solid #fff;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      animation: fadein 0.3s ease;
    }
    .winner-clone .clone-number {
      font-size: 3rem;
      background-color: #005050;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 5px;
      padding: 5px 10px;
      margin: 5px;
    }
    .winner-clone .clone-lives {
      font-size: 1.5rem;
      color: #fff;
      margin-top: 5px;
    }
    @keyframes fadein {
      from { transform: scale(0.8); opacity: 0; }
      to   { transform: scale(1);   opacity: 1; }
    }

    /* Overlay loterie */
    #lottery-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    .lottery-container {
      width: 400px;
      height: 400px;
      border: 2px solid #fff;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
      background: url("https://ik.imagekit.io/lakolo/lottery_wheel.png") no-repeat center center;
      background-size: cover;
    }
    .lottery-ball {
      position: absolute;
      width: 40px;
      height: 40px;
      background-color: #007575; /* même vert que les cartes */
      border-radius: 50%;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: "PlayerFont", sans-serif;
      font-size: 1.0rem;
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h1>
    <span>SQUID</span>
    <span class="shape-circle">O</span>
    <span class="shape-triangle">Δ</span>
    <span class="shape-square">■</span>
    <span>GAME</span>
  </h1>
  <p>À qui le tour ?</p>

  <!-- Overlay caché pour l'affichage en grand des gagnants -->
  <div id="winners-overlay"></div>
  <!-- Overlay pour l'animation de tirage au sort -->
  <div id="lottery-overlay"></div>

  <!-- Conteneur global -->
  <div id="players-global">
    <!-- Le conteneur principal pour afficher les teams ou la grille unique -->
    <div class="teams-container" id="teams-container"></div>

    <div class="buttons-container">
      <input id="lives-input" type="number" placeholder="Vies à supprimer" min="1" />
      <button id="submit-btn" onclick="processRound()">Soumettre les gagnants</button>
      <button id="reset-btn" onclick="confirmReset()">Réinitialiser les vies</button>
      <button id="undo-btn" onclick="undoAction()">Retour</button>
      <button id="voice-btn" onclick="toggleVoiceRecognition()">Activer la Reconnaissance Vocale</button>
      <button id="teams-btn" onclick="createTeams()">Créer les équipes</button>
      <button id="break-teams-btn" onclick="breakTeams()">Casser les équipes</button>
    </div>
  </div>

  <script>
    // === 0) Récupération du nombre de joueurs via l'URL ===
    const urlParams = new URLSearchParams(window.location.search);
    const numPlayers = parseInt(urlParams.get("players"), 10) || 100;

    // === 1) Players + snapshot pour annuler (retour) ===
    let players = Array.from({ length: numPlayers }, (_, i) => ({
      id: i + 1,
      lives: 6,
      isWinner: false,
      team: null,
    }));
    let lastPlayers = null; // stocke l'état précédent

    function saveState() {
      lastPlayers = JSON.parse(JSON.stringify(players));
    }

    function undoAction() {
      if (!lastPlayers) {
        console.warn("Aucune action à annuler");
        return;
      }
      players = JSON.parse(JSON.stringify(lastPlayers));
      hideWinners();
      renderPlayers();
    }

    function breakTeams() {
      saveState();
      players.forEach((p) => {
        p.team = null;
      });
      renderPlayers();
    }

    // === 1b) Transfert de vies
    function transferLives(donorId, receiverId, amount) {
      const donor = players.find((p) => p.id === donorId);
      const receiver = players.find((p) => p.id === receiverId);
      if (!donor || !receiver) return;
      if (donor.lives < amount) amount = donor.lives;
      donor.lives -= amount;
      receiver.lives += amount;
      renderPlayers();
    }

    // === 2) Audio fade in/out
    const audio = new Audio(
      "https://ik.imagekit.io/lakolo/Squid%20Game%20%20Piggy%20Bank%20Scene.mp3"
    );
    audio.volume = 1.0;
    let fadeInterval = null;
    function playAudioFadeIn() {
      if (fadeInterval) clearInterval(fadeInterval);
      audio.pause();
      audio.currentTime = 0;
      audio.volume = 0;
      audio.play().catch((err) => console.warn("Impossible audio:", err));
      fadeInterval = setInterval(() => {
        if (audio.volume < 1) {
          audio.volume = Math.min(audio.volume + 0.1, 1);
        } else {
          clearInterval(fadeInterval);
          fadeInterval = null;
        }
      }, 200);
    }
    function stopAudioFadeOut() {
      if (fadeInterval) clearInterval(fadeInterval);
      fadeInterval = setInterval(() => {
        if (audio.volume > 0.1) {
          audio.volume -= 0.1;
        } else {
          audio.pause();
          audio.currentTime = 0;
          clearInterval(fadeInterval);
          fadeInterval = null;
        }
      }, 200);
    }

    // === 3) Rendu players (avec regroupement par équipe ou non)
    function renderPlayers() {
      const teamsContainer = document.getElementById("teams-container");
      teamsContainer.innerHTML = "";

      // Cherche s'il y a au moins une team
      const hasTeam = players.some((p) => p.team !== null);
      if (!hasTeam) {
        // Tous en un bloc "sans équipe"
        const block = document.createElement("div");
        block.className = "team-block";

        const h2 = document.createElement("h2");
        h2.textContent = "Sans équipe";
        block.appendChild(h2);

        const grid = document.createElement("div");
        grid.className = "player-grid";

        players.forEach((p) => {
          const card = createPlayerCard(p);
          grid.appendChild(card);
        });

        block.appendChild(grid);
        teamsContainer.appendChild(block);
      } else {
        // On regroupe par team
        // d'abord on identifie les teams distinctes
        const distinctTeams = [
          ...new Set(players.filter((p) => p.team).map((p) => p.team)),
        ].sort((a, b) => a - b);

        distinctTeams.forEach((teamNum) => {
          const block = document.createElement("div");
          block.className = "team-block";

          const h2 = document.createElement("h2");
          h2.textContent = `Équipe ${teamNum}`;
          block.appendChild(h2);

          const grid = document.createElement("div");
          grid.className = "player-grid";

          // On affiche les joueurs de cette team
          players
            .filter((p) => p.team === teamNum)
            .forEach((p) => {
              const card = createPlayerCard(p);
              grid.appendChild(card);
            });

          block.appendChild(grid);
          teamsContainer.appendChild(block);
        });

        // On affiche éventuellement ceux qui ont team=null
        const noTeamPlayers = players.filter((p) => p.team === null);
        if (noTeamPlayers.length > 0) {
          const block = document.createElement("div");
          block.className = "team-block";

          const h2 = document.createElement("h2");
          h2.textContent = `Sans équipe`;
          block.appendChild(h2);

          const grid = document.createElement("div");
          grid.className = "player-grid";
          noTeamPlayers.forEach((p) => {
            const card = createPlayerCard(p);
            grid.appendChild(card);
          });

          block.appendChild(grid);
          teamsContainer.appendChild(block);
        }
      }
    }

    function createPlayerCard(player) {
      let cardClass = "player-card";
      if (player.isWinner) cardClass += " active";
      if (player.lives <= 0) cardClass += " no-lives";

      const playerCard = document.createElement("div");
      playerCard.className = cardClass;
      playerCard.onclick = () => toggleWinnerManually(player.id);

      const playerNumber = document.createElement("div");
      playerNumber.className = "player-card-number";
      playerNumber.textContent = player.id.toString().padStart(3, "0");

      const playerLives = document.createElement("div");
      playerLives.className = "player-lives";
      playerLives.textContent = `Vies: ${player.lives}`;

      playerCard.appendChild(playerNumber);
      playerCard.appendChild(playerLives);

      return playerCard;
    }

    function toggleWinnerManually(playerId) {
      saveState();
      const player = players.find((p) => p.id === playerId);
      if (!player) return;
      player.isWinner = !player.isWinner;
      renderPlayers();
    }

    function toggleWinner(playerId) {
      saveState();
      const p = players.find((x) => x.id === playerId);
      if (!p) return;
      p.isWinner = !p.isWinner;
      renderPlayers();
      showWinners();
    }

    function toggleWinnerInstant(playerId) {
      saveState();
      const p = players.find((x) => x.id === playerId);
      if (!p) return;
      p.isWinner = true;
      renderPlayers();
      showWinners();
    }

    // === 5) processRound
    function processRound() {
      saveState();
      hideWinners();
      const livesToRemove =
        parseInt(document.getElementById("lives-input").value) || 1;
      players.forEach((p) => {
        if (!p.isWinner && p.lives > 0) {
          p.lives -= livesToRemove;
          if (p.lives < 0) p.lives = 0;
        }
        p.isWinner = false;
      });
      renderPlayers();
    }

    // === 6) reset
    function confirmReset() {
      const sure = confirm("Êtes-vous sûr de vouloir réinitialiser ?");
      if (!sure) return;
      saveState();
      hideWinners();
      players.forEach((p) => {
        p.lives = 6;
        p.isWinner = false;
        p.team = null;
      });
      renderPlayers();
    }

    // === 7) Winners Overlay
    function showWinners() {
      const overlay = document.getElementById("winners-overlay");
      overlay.innerHTML = "";
      const winners = players.filter((p) => p.isWinner);
      if (winners.length === 0) {
        overlay.style.display = "none";
        return;
      }

      winners.forEach((w) => {
        const clone = document.createElement("div");
        clone.className = "winner-clone";
        clone.onclick = () => {
          saveState();
          w.isWinner = false;
          hideWinners();
          renderPlayers();
        };

        const cloneNumber = document.createElement("div");
        cloneNumber.className = "clone-number";
        cloneNumber.textContent = w.id.toString().padStart(3, "0");

        const cloneLives = document.createElement("div");
        cloneLives.className = "clone-lives";
        cloneLives.textContent = `Vies: ${w.lives}`;

        clone.appendChild(cloneNumber);
        clone.appendChild(cloneLives);
        overlay.appendChild(clone);
      });

      overlay.style.display = "flex";
    }
    function hideWinners() {
      const overlay = document.getElementById("winners-overlay");
      overlay.innerHTML = "";
      overlay.style.display = "none";
    }

    // === 8) showMinusLife
    function showMinusLife(playerId, lostValue) {
      // On cherche la carte
      const card = document.querySelector(
        `.player-card-number:contains(${String(
          playerId.toString().padStart(3, "0")
        )})`
      );
      // Sauf que :contains() n'existe pas nativement en JS, on fait un fallback
      // => on va brute force
      let el = null;
      const allNumbers = document.querySelectorAll(".player-card-number");
      allNumbers.forEach((n) => {
        if (n.textContent === playerId.toString().padStart(3, "0")) {
          el = n;
        }
      });
      if (!el) return;

      const rect = el.getBoundingClientRect();
      const minusEl = document.createElement("div");
      minusEl.className = "minus-life";
      minusEl.textContent = `-${lostValue}`;
      document.body.appendChild(minusEl);

      minusEl.style.left = rect.left + rect.width / 2 + "px";
      minusEl.style.top = rect.top + "px";

      minusEl
        .animate(
          [
            { transform: "translate(-50%, 0)", opacity: 1 },
            { transform: "translate(-50%, -50px)", opacity: 0 },
          ],
          {
            duration: 1000,
            easing: "ease-out",
          }
        )
        .onfinish = () => {
          document.body.removeChild(minusEl);
        };
    }

    // === 9) Reconnaissance vocale
    let recognition = null;
    let isVoiceActive = false;
    let interimMemory = new Set();
    let isCommandMode = false;

    function toggleVoiceRecognition() {
      if (!("webkitSpeechRecognition" in window)) {
        console.error("La reconnaissance vocale n'est pas supportée.");
        return;
      }

      const voiceBtn = document.getElementById("voice-btn");
      if (!recognition) {
        recognition = new webkitSpeechRecognition();
        recognition.lang = "fr-FR";
        recognition.interimResults = true;
        recognition.maxAlternatives = 1;
        recognition.continuous = true;

        recognition.onresult = (event) => {
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const result = event.results[i];
            const transcript = result[0].transcript.toLowerCase().trim();

            if (!result.isFinal) {
              if (isCommandMode) detectNumbersOnTheFly(transcript);
            } else {
              interimMemory.clear();
              if (transcript.includes("activer")) {
                isCommandMode = true;
                console.log("Mode commande activé !");
              }
              if (transcript.includes("désactiver")) {
                isCommandMode = false;
                console.log("Mode commande désactivé !");
              }
              if (isCommandMode) {
                handleVoiceResult(transcript);
              }
            }
          }
        };

        recognition.onerror = (e) => console.error("Erreur vocale:", e.error);
        recognition.onend = () => {
          if (isVoiceActive) recognition.start();
        };
      }

      if (!isVoiceActive) {
        recognition.start();
        isVoiceActive = true;
        voiceBtn.textContent = "Désactiver la Reconnaissance Vocale";
      } else {
        isVoiceActive = false;
        recognition.stop();
        voiceBtn.textContent = "Activer la Reconnaissance Vocale";
      }
    }

    function detectNumbersOnTheFly(text) {
      const digitMatches = text.match(/\d+/g);
      if (digitMatches) {
        digitMatches.forEach((numStr) => {
          const numVal = parseInt(numStr, 10);
          if (!interimMemory.has(numVal)) {
            interimMemory.add(numVal);
            toggleWinnerInstant(numVal);
          }
        });
      }
    }

    const spelledNumbers = {
      un: 1,
      une: 1,
      deux: 2,
      de: 2,
      trois: 3,
      quatre: 4,
      cinq: 5,
      six: 6,
      sept: 7,
      huit: 8,
      neuf: 9,
      dix: 10,
      devis: 2,
      paires: 2,
    };

    function handleVoiceResult(finalString) {
      console.log("Reco vocale (final):", finalString);
      const result = finalString;

      if (result.includes("retour")) {
        undoAction();
        return;
      }
      if (
        result.includes("retire moi tous les numéros") ||
        result.includes("retire-moi tous les numéros") ||
        result.includes("retiens-moi tous les numéros") ||
        result.includes("rupture moi tous les numéros")
      ) {
        saveState();
        hideWinners();
        players.forEach((p) => (p.isWinner = false));
        renderPlayers();
        return;
      }
      if (result.includes("gagnant")) {
        stopAudioFadeOut();
        playAudioFadeIn();
      }

      const perdrontMatch = result.match(/les autres perdront (\d+)/i);
      if (perdrontMatch) {
        saveState();
        hideWinners();
        stopAudioFadeOut();
        const livesToRemove = parseInt(perdrontMatch[1], 10);
        players.forEach((p) => {
          if (!p.isWinner && p.lives > 0) {
            p.lives -= livesToRemove;
            if (p.lives < 0) p.lives = 0;
            showMinusLife(p.id, livesToRemove);
          }
          p.isWinner = false;
        });
        renderPlayers();
        return;
      }
      if (result.includes("les autres perdent")) {
        saveState();
        hideWinners();
        stopAudioFadeOut();
        const spelledRegex =
          /les autres perdent (un|une|deux|de|trois|quatre|cinq|six|sept|huit|neuf|dix|devis|paires|\d+)/i;
        const spelledMatch = result.match(spelledRegex);
        if (spelledMatch) {
          let val = spelledMatch[1];
          if (spelledNumbers[val] !== undefined) {
            val = spelledNumbers[val];
          } else {
            val = parseInt(val, 10);
          }
          players.forEach((p) => {
            if (!p.isWinner && p.lives > 0) {
              p.lives -= val;
              if (p.lives < 0) p.lives = 0;
              showMinusLife(p.id, val);
            }
            p.isWinner = false;
          });
          renderPlayers();
        }
        return;
      }
      if (
        result.includes("les autres paires de vie") ||
        result.includes("les autres paires de devis")
      ) {
        saveState();
        hideWinners();
        stopAudioFadeOut();
        const val = 2;
        players.forEach((p) => {
          if (!p.isWinner && p.lives > 0) {
            p.lives -= val;
            if (p.lives < 0) p.lives = 0;
            showMinusLife(p.id, val);
          }
          p.isWinner = false;
        });
        renderPlayers();
        return;
      }
      if (result.includes("tu peux me transférer")) {
        saveState();
        hideWinners();
        const amountMatch = result.match(
          /(un|une|deux|de|trois|quatre|cinq|six|sept|huit|neuf|dix|devis|paires|\d+)/i
        );
        if (!amountMatch) return;

        let amountRaw = amountMatch[1].toLowerCase();
        let amountVal =
          spelledNumbers[amountRaw] !== undefined
            ? spelledNumbers[amountRaw]
            : parseInt(amountRaw, 10);

        const digits = result.match(/\d+/g);
        if (!digits || digits.length < 2) {
          console.warn("Pas assez de nombres pour détecter donneur / receveur");
          return;
        }
        const donorId = parseInt(digits[0], 10);
        const receiverId = parseInt(digits[1], 10);
        transferLives(donorId, receiverId, amountVal);
        return;
      }

      // "gagnant X Y Z"
      const matches = result.match(/\d+/g);
      if (matches) {
        saveState();
        matches.forEach((num) => {
          const pid = parseInt(num, 10);
          const pl = players.find((x) => x.id === pid);
          if (pl) pl.isWinner = true;
        });
        renderPlayers();
        showWinners();
      }
    }

    // ==============================
    // =========== ÉQUIPES ==========
    // ==============================
    function createTeams() {
      const nbEquipes = prompt("Combien d'équipes ?", "5");
      if (!nbEquipes || isNaN(nbEquipes) || nbEquipes <= 0) {
        return;
      }
      saveState();
      const numTeams = parseInt(nbEquipes, 10);

      // 1) Mélanger players
      let shuffled = players.slice();
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }

      // 2) Répartir
      let total = shuffled.length;
      let baseSize = Math.floor(total / numTeams);
      let remainder = total % numTeams;

      let teams = Array.from({ length: numTeams }, () => []);
      let idx = 0;
      for (let t = 0; t < numTeams; t++) {
        let size = baseSize + (remainder > 0 ? 1 : 0);
        remainder--;
        for (let s = 0; s < size; s++) {
          teams[t].push(shuffled[idx]);
          idx++;
        }
      }

      // Mettre .team
      teams.forEach((teamArr, i) => {
        teamArr.forEach((p) => {
          p.team = i + 1;
        });
      });

      // 3) Animation "façon euromillions" : boules se déplacent aléatoirement 5s
      showLotteryAnimation(shuffled, teams);
    }

    // Variables pour l'animation "euromillions"
    let animationInterval = null;
    let animationStartTime = null;
    let ballsState = [];

    function showLotteryAnimation(shuffled, teams) {
      const overlay = document.getElementById("lottery-overlay");
      overlay.innerHTML = "";
      overlay.style.display = "flex";

      const container = document.createElement("div");
      container.className = "lottery-container";
      overlay.appendChild(container);

      // Créer les boules avec positions & vitesses random
      ballsState = shuffled.map((p) => {
        let angle = Math.random() * 2 * Math.PI;
        let radius = 120; // zone de mouvement ~
        let x = 200 + radius * Math.cos(angle) - 20; // -20 => centre la boule
        let y = 200 + radius * Math.sin(angle) - 20;

        // vitesses random (entre -2 et +2)
        let vx = (Math.random() * 4) - 2;
        let vy = (Math.random() * 4) - 2;

        const ballDiv = document.createElement("div");
        ballDiv.className = "lottery-ball";
        ballDiv.textContent = p.id.toString().padStart(3, "0");
        ballDiv.style.left = x + "px";
        ballDiv.style.top = y + "px";
        container.appendChild(ballDiv);

        return { p, x, y, vx, vy, el: ballDiv };
      });

      // On lance l'animation
      animationStartTime = performance.now();
      animationInterval = requestAnimationFrame(moveBalls);

      // après 5s => on arrête
      setTimeout(() => {
        cancelAnimationFrame(animationInterval);
        // On supprime tout
        container.innerHTML = "";
        showTeamsResult(teams);
      }, 5000);
    }

    function moveBalls(timestamp) {
      // dt => temps depuis la dernière frame
      animationInterval = requestAnimationFrame(moveBalls);

      ballsState.forEach((b) => {
        // maj positions
        b.x += b.vx;
        b.y += b.vy;

        // On fait un bounce simple dans la bounding box (cercle ~)
        // centre (200,200), rayon = 180
        let centerX = 200, centerY = 200;
        let dx = b.x + 20 - centerX; // +20 => centre de la boule
        let dy = b.y + 20 - centerY;
        let dist = Math.sqrt(dx*dx + dy*dy);

        const maxRadius = 180; // approximatif
        if (dist + 20 > maxRadius) {
          // on rebondit => on inverse vx,vy
          // direction entre le centre et la boule
          // vect normal => dx, dy
          let nx = dx / dist; 
          let ny = dy / dist;
          // projection => on inverse
          let dot = b.vx * nx + b.vy * ny; 
          // rebond
          b.vx -= 2 * dot * nx;
          b.vy -= 2 * dot * ny;
        }

        // Update style
        b.el.style.left = b.x + "px";
        b.el.style.top = b.y + "px";
      });
    }

    function showTeamsResult(teams) {
      const overlay = document.getElementById("lottery-overlay");
      overlay.innerHTML = "";

      const resultDiv = document.createElement("div");
      resultDiv.style.display = "flex";
      resultDiv.style.flexWrap = "wrap";
      resultDiv.style.gap = "20px";
      overlay.appendChild(resultDiv);

      teams.forEach((teamArr, i) => {
        const teamBox = document.createElement("div");
        teamBox.style.border = "2px solid #fff";
        teamBox.style.padding = "10px";
        teamBox.style.minWidth = "150px";
        teamBox.style.margin = "10px";

        const title = document.createElement("h2");
        title.textContent = `Équipe ${i + 1}`;
        teamBox.appendChild(title);

        teamArr.forEach((p) => {
          const pLine = document.createElement("div");
          pLine.textContent = `Joueur ${p.id.toString().padStart(3, "0")} (vies=${p.lives})`;
          teamBox.appendChild(pLine);
        });

        resultDiv.appendChild(teamBox);
      });

      const closeBtn = document.createElement("button");
      closeBtn.textContent = "Fermer";
      closeBtn.onclick = () => {
        overlay.style.display = "none";
        renderPlayers(); // on met à jour l'affichage final
      };
      overlay.appendChild(closeBtn);
    }

    // Start
    renderPlayers();
  </script>
</body>
</html>
